{"title": "能从远程获得乐趣的 Linux 命令", "zanNum": "1", "commentNum": " 1 评论", "markNum": " 3 收藏", "source": "Jason Baker", "coverImage": "http://jbcdn2.b0.upaiyun.com/2019/01/f83bd996007b0dc95b43d441fb3dfa3d.png", "content": "使用这些工具从远程了解天气、阅读资料等。;我们即将结束为期 24 天的 Linux 命令行玩具日历。希望你有一直在看，如果没有，请回到;，从头看过来。你会发现 Linux 终端有很多游戏、消遣和奇怪之处。;虽然你之前可能已经看过我们日历中的一些玩具，但我们希望每个人都遇见一个新事物。;今天的玩具（实际是玩具集合）有点不同。到目前为止，我主要是想把重点放在那些独立的玩具上，并且完全可在开源许可下使用。但是我从读者那里得到了一些很好的建议，利用开源工具远程访问一些开源或者不开源的东西。今天，我将介绍其中的一些。;第一个是经典之作：使用 Telnet 观看星球大战的 ASCII 演绎版本。你的系统可能已经安装了 Telnet，因此你只需运行：;我第一次看到它是十年之前，因此我对于它还存在有点惊奇。如果你还没看过，请留出一点时间看一下。你不会后悔的。;接下来，Opensource.com 的撰稿人 ; 提出了一种从终端获取当地天气的方法。它很简单，你只需安装 ;（或者，;）。;最后，在假期中虽然你可以从;浏览你喜欢的网站（包括 Opensource.com），但有一些我最喜欢的网站可以通过专用客户端更轻松地浏览。其中两个是 Reddit 和 Hacker News，有人推荐给我一些它们的客户端，你可能也想尝试，它们都使用开源许可。我尝试过 ; （Hacker News） 和 ; （Reddit），它们都还不错。; ; "}
{"title": "5 个好用的开发者 Vim 插件", "zanNum": "1", "commentNum": "  评论", "markNum": "  收藏", "source": "Ricardo Gerardi", "coverImage": "http://jbcdn2.b0.upaiyun.com/2019/02/bd52853a7b3ec8810c11e90c1b77f44b.jpg", "content": "通过这 5 个插件扩展 Vim 功能来提升你的编码效率。;我用 Vim 已经超过 20 年了，两年前我决定把它作为我的首要文本编辑器。我用 Vim 来编写代码、配置文件、博客文章及其它任意可以用纯文本表达的东西。Vim 有很多超级棒的功能，一旦你适合了它，你的工作会变得非常高效。;在日常编辑工作中，我更倾向于使用 Vim 稳定的原生功能，但开源社区对 Vim 开发了大量的插件，可以扩展 Vim 的功能、改进你的工作流程和提升工作效率。;以下列举 5 个非常好用的可以用于编写任意编程语言的插件。; 插件可以帮助你插入和删除成对的文字，如花括号、圆括号或引号。这在编写代码时非常有用，因为很多编程语言都有成对标记的语法，就像圆括号用于函数调用，或引号用于字符串定义。;Auto Pairs 最基本的功能是在你输入一个左括号时会自动补全对应的另一半括号。比如，你输入了一个 ;，它会自动帮你补充另一半 ;。相反，如果你用退格键删除开头的一半括号，Auto Pairs 会删除另一半。;如果你设置了自动缩进，当你按下回车键时 Auto Pairs 会在恰当的缩进位置补全另一半括号，这比你找到放置另一半的位置并选择一个正确的括号要省劲多了。;例如下面这段代码：;在 ; 后面输入一个左花括号按下回车会产生下面的结果：;Auto Pairs 提供了大量其它选项（你可以在 ; 上找到），但最基本的功能已经很让人省时间了。; 插件给 Vim 增加了代码注释的功能，类似在 IDEintegrated development environment 中注释功能。有了这个插件，你可以一键注释单行或多行代码。;NERD Commenter 可以与标准的 Vim ; 插件配合，所以它能理解一些编程语言并使用合适的方式来注释代码。;最易上手的方法是按 ; 组合键来切换注释当前行。Vim 默认的 Leader 键是 \\;。;在可视化模式Visual mode中，你可以选择多行一并注释。NERD Commenter 也可以按计数注释，所以你可以加个数量 n 来注释 n 行。;还有个有用的特性 “Sexy Comment” 可以用 ; 来触发，它的块注释风格更漂亮一些。例如下面这段代码：;选择 ; 函数中的所有行然后按下 ; 会出来以下注释效果：;因为这些行都是在一个块中注释的，你可以用 ; 组合键一次去掉这里所有的注释。;NERD Commenter 是任何使用 Vim 写代码的开发者都必装的插件。; 插件可以帮你“环绕”现有文本插入成对的符号（如括号或双引号）或标签（如 HTML 或 XML 标签）。它和 Auto Pairs 有点儿类似，但是用于处理已有文本，在编辑文本时更有用。;比如你有以下一个句子：;当你的光标处于引起来的句中任何位置时，你可以用 ; 组合键删除句子两端的双引号。;你也可以用 ; 把双端的双引号换成单引号：;或者再用 ; 替换成中括号：;它对编辑 HTML 或 XML 文本中的标签tag尤其在行。假如你有以下一行 HTML 代码：;当光标在 “awesome” 这个单词的任何位置时，你可以按 ysiw<em> 直接给它加上着重标签（<em>;）：;注意它聪明地加上了 </em> ; 闭合标签。;Vim Surround 也可以用 ; 缩进文本并加上标签。比如你有以下文本：;你可以用 ;加上 ; 标签，注意生成的段落是自动缩进的。;Vim Surround 有很多其它选项，你可以参照 ; 上的说明尝试它们。; 插件对使用 Git 作为版本控制工具的人来说非常有用。它会在 Vim 的行号列旁显示 ; 的差异标记。假设你有如下已提交过的代码：;当你做出一些修改后，Vim Gitgutter 会显示如下标记：; 标记表示在第 5 行和第 6 行之间删除了一行。; 表示第 8 行有修改，; 表示新增了第 11 行。;另外，Vim Gitgutter 允许你用 ; 和 ; 在多个有修改的块之间跳转，甚至可以用 ; 来暂存某个变更集。;这个插件提供了对变更的即时视觉反馈，如果你用 Git 的话，有了它简直是如虎添翼。; 是另一个将 Git 工作流集成到 Vim 中的超棒插件。它对 Git 做了一些封装，可以让你在 Vim 里直接执行 Git 命令并将结果集成在 Vim 界面里。这个插件有超多的特性，更多信息请访问它的 ; 项目页面。;这里有一个使用 Vim Fugitive 的基础 Git 工作流示例。设想我们已经对下面的 Go 代码做出修改，你可以用 ; 调用 ; 来查看每行最后的提交信息：;可以看到第 8 行和第 11 行显示还未提交。用 ; 命令检查仓库当前的状态：;Vim Fugitive 在分割的窗口里显示 ; 的输出结果。你可以在该行按下 ; 键用该文件的名字暂存这个文件的提交，再按一次 ; 可以取消暂存。这个信息会随着你的操作自动更新：;现在你可以用 ; 来提交修改了。Vim Fugitive 会打开另一个分割窗口让你输入提交信息：;按 ; 保存文件完成提交：;然后你可以再用 ; 检查结果并用 ; 把新的提交推送到远程。;Vim Fugitive 的 GitHub 项目主页有很多屏幕录像展示了它的更多功能和工作流，如果你喜欢它并想多学一些，快去看看吧。;这些 Vim 插件都是程序开发者的神器！还有另外两类开发者常用的插件：自动完成插件和语法检查插件。它些大都是和具体的编程语言相关的，以后我会在一些文章中介绍它们。;你在写代码时是否用到一些其它 Vim 插件？请在评论区留言分享。"}
{"title": "学会这两件事，让你成为 Git 老司机", "zanNum": "1", "commentNum": " 2 评论", "markNum": "  收藏", "source": "伯乐在线", "coverImage": "https://camo.githubusercontent.com/d98880e58e8bbcbe39d18692601bdd78ad51057c/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f302a744a713852535f557633523973353645", "content": "如果你曾经有上述问题，那么这篇文章很适合你。这篇文章介绍了一个让你成为 Git 老司机的清单。;情景 1;假设你已经提交了一堆文件，并发现输入的提交信息实际上并不清晰。现在你要更改提交消息。为此，你可以使用 ;：;假设你要提交六个文件，但你最终错误地只提交了五个文件。你可能认为可以创建新提交并将第六个文件添加到该提交。;这种方法没错。但是，为了保持整洁的提交历史，如果你可以以某种方式将此文件加入到你之前的提交本身，那岂不是更好？这也可以通过 ; 完成：; 表示提交信息不会更改。;无论你何时在 Git 进行提交，提交都会附上作者名称和作者电子邮箱。通常，当你第一次配置 Git 时，就需要设置作者和电子邮箱。你无需担心每次提交的作者详细信息。;也就是说，对于特定项目，你可能希望使用不同的电子邮箱 ID。你需要使用以下命令为该项目配置电子邮箱 ID：;假设你忘记配置电子邮箱，并且已经完成了第一次提交。; 命令也可以用于更改先前提交的作者消息。可以使用以下命令更改提交的作者信息：;应该;本地仓库使用 ; 命令。在远端仓库使用 ; 命令会制造大量混乱。;假设你正在处理一段代码。你知道代码大约需要十天完成。在这十天内，其他开发人员也将提交代码到远程仓库。;将本地仓库代码与远程仓库代码保持同步是个;。这在你拉取请求时会避免许多合并冲突的操作。因此，你应该每两天从远程仓库中拉取一个变更。;每次将代码从远程仓库拉取到本地仓库时，都会在本地操作中创建新的合并提交。这意味着你的本地历史提交记录会有大量的合并提交，这会让审阅人员头大。;上面是历史提交记录在本地仓库中的显示方式。;这就需要用到 ; 了。;举个🌰。;此图显示了发布（release）分支和功能（feature）分支中的提交。;当执行变基时，你的目标是确保功能分支从发布分支获取最新代码。;变基命令尝试逐个添加每个提交，并检查冲突。这听起来是不是有点头大？;让我画个图帮助理解。;这显示了变基内部实际做的事情：;你现在是个 Git 老司机了。😃;在这篇文章中，你了解到：;这两个都是非常实用的概念。探索 Git 的世界，继续学习吧。;任选一种支付方式;\n                        ;\n            \n                            ;\n                    "}
{"title": "克劳德·香农（信息论之父）：天才的解决问题之道", "zanNum": "1", "commentNum": " 1 评论", "markNum": " 2 收藏", "source": "伯乐在线", "coverImage": "https://camo.githubusercontent.com/16a2334128d990c2d2fab7c7ade060028e372ac9/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323630302f312a5765354a51583961674871706866774a593756315a412e6a706567", "content": "克劳德·香农花了差不多10年，制定了一套完整的、具有开创性意义的信息理论。;一开始在研究生院时，他只是想给当时的众多信息技术（如电话，收音机，电视机）建立一套通用的技术基础。;直到1948年，他发表了一篇名为《通信的数学理论》的论文。;他的重大贡献可不止这篇论文。当他还在MIT攻读硕士时，年仅21岁的他发表了一篇论文，这也被大家认为是20世纪最重要的硕士论文。;对于普通人来说，这无足轻重。香农并不是一个家喻户晓的名字。但如果没有他的贡献，我们所说的现代计算机可能不会存在。他巨大的的影响力不仅在计算机科学领域，而且涉及物理学和工程学。;天才一词被到处滥用，但如克劳德·香农这样真正配得上这个称号的人却屈指可数。他思考的方式异于常人，而且充满趣味。;讲到成就这样一位天才背后的原因，不得不提的就是他解决问题的方式。他不只是提出问题然后解决问题，而是他通过自己的方法，开发了一套思考过程来指导他洞察问题的本质。;虽然我们不太可能遇到他面临的问题，但这种解决问题的方法及其背后的推理还是有很多可以借鉴的地方，当我们了解了之后，或许可以帮我们更敏锐地思考。;一切问题都有其表现形式。我们必须先去理解问题，再着手解决问题。;找到问题答案固然很重要，但找到一种提问方式，以便更易于找到问题答案的重要性却被大多数人忽视了。;我们通常把目光聚焦在不同的细节上，想找到它们之间的联系，却没有集中精力去培养一种寻找问题本质的直觉。;香农恰恰反其道而行之。在他的自传《A Mind at Play》中，他坦言一些同时代的数学家觉得他思考不够严谨，步骤不够连贯。他们想要的是细节。;但是香农的推理方式是，只有你去掉问题中无关的细节，才能看到问题的本质，才能找到问题的答案。;通常情况下，当你看到问题的本质时，你可能觉得这根本不是之前思考的那个问题。所以，拿到一个问题时，在你纠结细节之前，以更宏观的角度来思考是很重要的，否则，你一开始就可能走歪了。;细节很重要，也很有用。很多细节的重要程度、能起多大作用跟其表现方式有关。但同样的，很多细节也没什么用。;如果一开始没有找到问题的关键所在，而是带着错误的细节信息就出发了，那样只会收集越来越多的错误信息，直到走进死胡同里。;从剔除无关细节开始，这样你才不会深陷迷雾当中，然后才能找到问题的本质。;找到问题的真正形式，这几乎和问题答案一样重要。;1952年，香农在贝尔实验室发表了一次演讲。演讲中，他深入分析了他如何创造性地思考他面临的问题。;除了简化问题和寻找问题本质，他还提到了其他的方法，这些方法在表面上似乎没什么作用，但对于创造性思考却至关重要。;当我们在一个问题上纠结了很长时间之后，通常会形成一种管窥思维，使得思路一直在一条链路上徘徊。逻辑思考总是从一个点出发，运用推理，建立连接，如果一切顺利，每次都会把我们带到同一个终点。;创造性思维则有些不同。它也建立连接，但比起逻辑思维，它是一种更发散、更具偶然性的思考模式。;香农的其中一个诀窍就是，他会把一个问题通过各种各样的方式来重构并进行对比。这可能会对问题进行夸大、或简略、或改变措辞、或转换不同的角度、或反转。;这样做是为了获得一种大局观，让他能更全面地看问题。;在思考问题时，我们很容易陷入自我的思维怪圈之中，要打破这种思维怪圈，最好的方式是改变参考点。不必颠覆自己对问题的直觉认知或是已认定的问题本质，而仅仅是改变表达方式。;例如，我们可以问：这个问题最好的解决方式是什么？并且也可以问：最糟糕的解决方式呢？两者都包含信息，所以我们都需要剖析。;就如同一个问题有多种形式，也有多种不同的外在呈现的模样。 不同的模样蕴含着不同的真相。;想法的质量固然重要，但其数量的作用也不容小觑。但并不是仅关注于想法的总数，而是关注你得到这些想法的过程。;为了解决问题，你必须有一个好想法。但反过来，要有一个好想法，首先你需要筛选掉很多平庸的念头。然而，即便如此，并不意味着要把脑子里所有的想法都拿出来过一遍吗，肯定有比这更好的方法。;在二战期间，香农遇到了同为计算机科学先驱的艾伦·图灵。图灵在美国的那段时间，他们几乎每天一起喝茶。多年来，他们仍保持着联系，两人都尊重彼此的想法并享受对方的陪伴。;当被问到天才具有什么特质时，香农用了一个图灵告诉他的类比，也是图灵经过敏锐地观察后得出的。以下是他的原话：;\n“有些人，你给他/她一个点子，他/她只会回你半个，但有些人能回你两个”;\n香农谦逊地否认了自己属于后者，而牛顿这样的人才是。但他的话也说明了，真正对解决问题发挥作用的，决不仅仅是点子的数量。;每个输入的信息都有其核心的精髓，能帮我们揭开掩盖真相的面纱。这个真相是不同问题的多种不同解决方案的基础。;我认为，香农想说的是，要产生好点子，就要善于发掘每个输入信息所蕴含的本质。如果你弄错了其本质，就可能产生出平庸的点子，但只要你能够尽可能的触及问题的本质，就能越快地得出真知灼见。;让你的想法产生双倍的成效只是第一步，真正带来本质区别的是要抓住本质。;人的一生大部分时刻，无论在你的工作中、人际交往中、还是关系到你的幸福感的时候，归结起来就是发现问题，解决问题，好让你能继续前进。;克劳德·香农或许是一个具有独特思维的天才，但他思考问题的过程并非常人所不可及。他的长处在于善于运用该过程来解决问题。;优秀的解决问题的能力关乎批判性思维和创造性思维。而综合两者的最好的方式便是在思考的过程中，让两者各放异彩。;思维模式塑造我们的思想。正确的思维模式应该成为我们追求的目标。"}
{"title": "在 Linux 命令行上拥有一头奶牛", "zanNum": "1", "commentNum": "  评论", "markNum": "  收藏", "source": "Jason Baker", "coverImage": "http://jbcdn2.b0.upaiyun.com/2018/12/8f2a2196313a36e53c18a9d2f4bbdf98.png", "content": "使用 cowsay 实用程序将牛的话语带到你的终端输出。;欢迎来到 Linux 命令行玩具第四天。如果这是你第一次访问这个系列，你可能会问自己，什么是命令行玩具。我们也在考虑这一点，但是一般来说，这可能是一个游戏，或者任何简单的娱乐，可以帮助你在终端玩得开心。;你们中的一些人会见过我们之前的选中的各种玩具，但是我们希望至少有一个对每个人来说都是新的。因为几乎所有我告诉他这个系列的人都已经问过它了，所以今天的选中的玩具是必须提及的。;你也不会认为我们会在不提及 ; 的情况下完成这个系列，对吧？; 是一个神奇的实用程序，它将文本作为 ASCII 艺术牛的讲话文本输出。;你可能会发现 ; 打包在你的默认存储库中，甚至可能已经安装了。对我来说，在 Fedora，像这样安装:;然后，用 ; 调用它，然后是你的消息。也许你想到昨天我们谈到的 ; 连接起来。;就这样！; 还有点小变体，称为 cow 文件，通常可以在 ; 找到 ，要查看系统上可用的 cow 文件，请在 ; 之后使用 ; 。然后，用 ; 试试其中之一。;我对 ; 的真正不满是，我今天没有足够的时间来为牛的挤奶 —— 一语双关。牛排价格太高了，我只是开个玩笑。;更严重的是，我已经完全忘记了 ; 直到我在学习 Ansible 的剧本时再次遇到它。如果你碰巧安装了 ;，当你运行Ansible 的剧本时，你会从一队奶牛那里获得输出。例如，运行这个剧本：;可能会给你以下信息：; 在 GPLv3 许可证下可用，您可以在 GitHub 上找到 它的 Perl ;。我也见过其他语言的版本，所以可以看看其他变体；例如，这是 ;。用你选择的语言实现你自己的版本可能是一项有趣的编程学习任务。;既然讲完了 ;，我们可以去更绿色的牧场了。;你有希望我来介绍的喜欢的命令行玩具吗？这个系列的排期大部分都填好了，但我还有一些空位方。在下面的评论中让我知道，我会来看看。如果有空间，我会尝试把它包括进去。如果没有，但是我收到了一些好的意见，我在结尾提及。;看看昨天的玩具，;，明天再来看看另一个！; "}
{"title": "Python 中星号的本质及其使用方式", "zanNum": "1", "commentNum": " 1 评论", "markNum": " 2 收藏", "source": "伯乐在线", "coverImage": "https://images.unsplash.com/photo-1526379095098-d400fd0bf935?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1189&q=80", "content": "在 Python 中有很多地方可以看到;和;。在某些情形下，无论是对于新手程序员，还是从其他很多没有完全相同操作符的编程语言迁移过来的人来说，这两个操作符都可能有点神秘。因此，我想讨论一下这些操作符的本质及其使用方式。;多年以来，;和;操作符的功能不断增强。在本文中，我将讨论目前这些操作符所有的使用方法，并指出哪些使用方法只能在目前的 Python 版本中应用。因此，如果你学习过 Python 2 中;和;的使用方法，那么我建议你至少浏览一下本文，因为 Python 3 中添加了许多;和;的新用途。;如果你是新接触 Python 不久，还不熟悉关键字参数(亦称为命名参数)，我建议你首先阅读我有关;的文章。;在本文中， 当我讨论;和;时，我指的是;和; ; 操作符，而不是 ; 操作符。;也就是说，我讲述的不是乘法和指数运算：;我们讨论的是;和;前缀运算符，即在变量前使用的;和;运算符。例如:;上述代码中展示了;的两种用法，没有展示;的用法。;这其中包括：;即使你认为自己已经熟悉; 和 ;的所有使用方法，我还是建议你查看下面的每个代码块，以确保都是你熟悉的内容。在过去的几年里，Python 核心开发人员不断地为这些操作符添加新的功能，对于使用者来说很容易忽略; 和 ;‘的一些新用法。;当调用函数时，;运算符可用于将一个迭代项解压缩到函数调用中的参数中：; ;代码行将;列表中的所有项作为独立的参数传递给;函数调用，甚至不需要我们知道列表中有多少个参数。;运算符在这里远不止是语法糖而已。要想用一个特定的迭代器将所有项作为独立的参数传输，若不使用;是不可能做到的，除非列表的长度是固定的。;下面是另一个例子：; ; ;这里我们接受一个二维列表并返回一个“转置”的二维列表。;操作符完成了类似的操作，只不过使用了关键字参数。;运算符允许我们获取键-值对字典，并在函数调用中将其解压为关键字参数。;根据我的经验，使用;将关键字参数解压缩到函数调用中并不常见。我最常看到它的地方是在实现继承时：对;的调用通常包括;和;。;如 Python 3.5 那样，在函数调用中，;和;都可以被多次使用。;有时，多次使用;会很方便：; ;多次使用;也可以达到相似的效果:;不过，在多次使用;时需要特别小心。Python 中的函数不能多次指定相同的关键字参数，因此在每个字典中与;一起使用的键必须能够相互区分，否则会引发异常。;在定义函数时，;运算符可用于捕获传递给函数的位置参数。位置参数的数量不受限制，捕获后被存储在一个元组中。;这个函数接受的参数数量不受限制：;Python 的;和;函数接受的位置参数数量不受限制。;的这种参数压缩用法，允许我们创建像;和;一样的函数，接受任意数量的参数。;运算符也有另外一个功能：我们在定义函数时，可以使用; 捕获传进函数的任何关键字参数到一个字典当中:; 将捕获我们传入这个函数中的任何关键字参数，并将其放入一个字典中，该字典将引用;参数。;在 Python 3 中，我们现在拥有了一种特殊的语法来接受只有关键字的函数参数。只有关键字的参数是; 使用关键字语法来指定的函数参数，也就意味着不能按照位置来指定它们。;在定义函数时，为了接受只有关键字的参数，我们可以将命名参数放在;后：;上面的函数可以像这样使用：;参数;和;在;后面，这意味着它们; 被指定为;。如果我们试图按照位置来指定它们，我们会得到一个报错：; ;这种行为是通过 ; 被引入到 Python 中的。;只使用关键字参数的特性很酷，但是如果您希望只使用关键字参数而不捕获无限的位置参数呢?;Python 使用一种有点奇怪的 单独; 语法来实现：;这个函数接受一个;参数，可以按照位置或名字来指定此参数（作为第一个参数），以及关键字参数;，这个填充值参数只使用关键字。这意味着我们可以像下面这样调用 with_previous：;但像这样就不可以：;这个函数接受两个参数，其中;参数;。;我通常在获取任意数量的位置参数时只使用关键字参数，但我有时使用这个;强制按照位置指定一个参数。;实际上，Python 的内置;函数使用了这种方法。如果你查看;的帮助信息，将看到以下信息：;在;的官方说明中，有一个单独的;参数。;Python 3 还新添了一种 ; 运算符的使用方式，它只与上面定义函数时和调用函数时;的使用方式相关。;现在，;操作符也可以用于元组拆包：;如果你想知道什么情况下可以在你自己的代码中使用它，请查看我关于 ; 文章中的示例。在那篇文章中，我将展示如何使用;操作符作为序列切片的替代方法。;通常当我教;的时候，我告诉大家只能在多重赋值语句中使用一个;表达式。实际来说这是不正确的，因为可以在嵌套解包中使用两个;（我在元组解包文章中讨论了嵌套解包）：;但是，我从来没见过它有什么实际用处，即使你因为它看起来有点神秘而去寻找一个例子，我也并不推荐这种使用方式。;将此添加到 Python 3.0 中的 PEP 是 ;，其篇幅不是很长。;Python 3.5 通过 ; 引入了大量与;相关的新特性。其中最大的新特性之一是能够使用;将迭代器转储到新列表中。;假设你有一个函数，它以任一序列作为输入，返回一个列表，其中该序列和序列的倒序连接在了一起：;此函数需要多次将序列转换为列表，以便连接列表并返回结果。在 Python 3.5 中，我们可以这样编写函数：;这段代码避免了一些不必要的列表调用，因此我们的代码更高效，可读性更好。;下面是另一个例子：;该函数返回一个新列表，其中给定列表(或其他序列)中的第一项被移动到了新列表的末尾。; 运算符的这种使用是将不同类型的迭代器连接在一起的好方法。; 运算符适用于连接任何种类的迭代器，然而 ; 运算符只适用于类型都相同的特定序列。;除了创建列表存储迭代器以外，我们还可以将迭代器转储到新的元组或集合中：;注意，上面的最后一行使用了一个列表和一个生成器，并将它们转储到一个新的集合中。在此之前，并没有一种简单的方法可以在一行代码中完成这项工作。曾经有一种方法可以做到这一点，可是并不容易被记住或发现：; ;PEP 448 还通过允许将键/值对从一个字典转储到一个新字典扩展了;操作符的功能：;我还写了另一篇文章：;。;不过，;操作符不仅仅可以用于合并两个字典。;例如，我们可以在复制一个字典的同时添加一个新值：;或者在复制/合并字典的同时重写特定的值：;Python 的 ; 和 ; 运算符不仅仅是语法糖。 ; 和 ; 运算符允许的某些操作可以通过其他方式实现，但是往往更麻烦和更耗费资源。而且 ; 和 ; 运算符提供的某些特性没有替代方法实现：例如，函数在不使用 ; 时就无法接受任意数量的位置参数。;在阅读了; 和 ; 运算符的所有特性之后，您可能想知道这些奇怪操作符的名称。不幸的是，它们的名字并不简练。我听说过; 被称为“打包”和“拆包“运算符。我还听说过其被称为“splat”(来自 Ruby 世界)，也听说过被简单地称为“star”。;我倾向于称这些操作符为“星”和“双星”或“星星”。这种叫法并不能区分它们和它们的中缀关系(乘法和指数运算)，但是通常我们可以从上下文清楚地知道是在讨论前缀运算符还是中缀运算符。;请勿在不理解; 和 ; 运算符的前提下记住它们的所有用法！这些操作符有很多用途，记住每种操作符的具体用法并不重要，重要的是了解你何时能够使用这些操作符。我建议使用这篇文章作为一个;或者制作你自己的备忘单来帮助你在 Python 中使用解; 和 ; 。;想了解更多关于 Python 的知识吗？我每周通过实时聊天分享我最喜欢的 Python 资源、回答 Python 问题。在下方注册，我将回答你提出的关于如何使 Python 代码更具有描述性、可读性和更 Python 化的;。"}
{"title": "5 款 Linux 街机游戏", "zanNum": "1", "commentNum": "  评论", "markNum": "  收藏", "source": "Joshua Allen Holm", "coverImage": "http://jbcdn2.b0.upaiyun.com/2019/01/3d62608ee84e9b8601819c7609b43f24.jpg", "content": "长久以来，游戏都是 Linux 的软肋。近些年，Steam、GOG 等游戏发布平台上不少商业游戏都开始支持 Linux，这对于 Linux 的游戏生态来说是件好事，但是我们能在这些平台上玩到的游戏通常是不开源的商业作品。当然，这些游戏在一个开源的操作系统上运行，但对于一个开源提倡者来说这似乎还不够纯粹。;那么，我们能找到既自由开源又能给玩家带来完整游戏体验的优质游戏吗？当然！虽然绝大多数的开源游戏很难和 3A 商业游戏大作竞争，但仍然有不少各种类型的开源游戏，不仅内容有趣而且直接可以通过几大 Linux 发行版本库中直接安装。;本文首先介绍 Linux 开源游戏中的街机类型游戏，在之后的文章中，我将介绍桌面和卡牌游戏，解谜游戏，竞速游戏，以及策略模拟游戏。; 是一个近现代太空背景下的滚动页面射击游戏。开发初期它是一个闭源游戏，但它的代码和素材而后以开源许可证发布了。游戏玩法和大多数此类游戏大同小异，但它有质量极高的 3D 画面。飞船和武器升级可以通过击杀敌人所获得的点数购买。游戏的难度可以选择，因此适合新手以及想要追求挑战的硬核玩家。;安装太空危机，你只需要在终端下运行以下指令：; 是一个俯瞰式视角的快节奏坦克战斗游戏。玩家可以选择三种不同的陆地坦克，操纵其在地图上前行，收集道具并且尝试炸飞敌军。它有四种游戏模式，死亡竞赛（又称“死斗”）、团队死斗、夺旗模式和合作模式。死斗和夺旗模式下，分别有 9 张地图可供玩家选择，合作模式则有 4 张。该游戏支持分屏本地双人游戏，以及在线多人竞技。游戏节奏很快，默认一次战役仅 5 分钟，因此，坦克战役十分适合想要利用零碎时间快速来一局的玩家。;安装坦克战役，你只需要在终端下运行以下指令：; 是一个自上而下的太空射击游戏，游戏机制类似传统街机游戏 “爆破彗星Asteroids”。玩家在操控一个太空船的同时向敌方射击并躲避敌军的弹幕射击。游戏有标准的死斗和团体死斗模式，除此之外也有更新鲜的比赛形式 —— 例如在一个模式下，玩家需要控制一个球使其进入敌方母星。该游戏支持本地多人游戏，但遗憾的是不支持多人联机。该游戏的开发更新似乎已经停止，所以该游戏之后增加联机模式的几率很小，但就算没有联机支持，这个游戏仍然值得一试。;安装火星，你只需要在终端下运行以下指令：; 的游戏灵感来源自世嘉的 “超级猴子球Super Monkey Ball” ，玩家需要将一个球在 3D 球场上运动起来，但是玩家控制的不是球，而是球场。游戏任务是在规定的时限内，收集足够多的金币从而打开该关卡的出口并且将小球落进该洞中。游戏可以调整难度，从休闲到难以超乎想象，可以适应不同的玩家需求。该游戏支持键盘/鼠标以及控制杆操作。;安装不存在之球，你只需要在终端下运行以下指令:; 是继任天堂超级马里奥后的一款 2D 的平台跳跃游戏。Linux 的吉祥物企鹅 Tux 代替了马里奥，而鸡蛋对应着马里奥系列中的蘑菇能力提升。当 Tux 获得了鸡蛋得到了能力提升，它便可以收集花朵，而花朵可以带来新的附加特殊能力。火焰花在关卡中最为常见，收集了火焰花的 Tux 可以掷出火球。除此之外，冰冻花/空气花/土地花也在游戏的程序中。收集星星的能力提升能使 Tux 暂时变得隐形，就如同马里奥系列游戏。该游戏最基础的一组关卡，冰之岛也有 30 关之多，因此游戏的内容和流程和超级马里奥系列一般长。SuperTux 还有一些附加关卡，例如三个额外奖励小岛、一个森林之岛、一个万圣节岛、一个孵化处，以及很多测试关卡。SuperTux 有一个自带的关卡编辑器，所以玩家可以创建他们的原创关卡。;安装超级 Tux，你只需要在终端下运行以下指令:;如果我没有在上文中提及你最喜欢的开源街机游戏，欢迎在评论中分享。;Joshua Allen Holm – 是 Opensource.com 的社区协调者之一。他的主要兴趣有数字人文、学术开放以及公开教育资源。你可以在 GitHub、GitLab、LinkedIn 和 Zotero 上找到他。可以通过 ; 联系到他。; "}
{"title": "cat 命令的源码进化史", "zanNum": "1", "commentNum": "  评论", "markNum": "  收藏", "source": "伯乐在线", "coverImage": "http://jbcdn2.b0.upaiyun.com/2019/01/171da56db445e8be2588f20355c6cb5c.jpeg", "content": "有一次，我跟我的亲戚有一场争论，是关于读一个计算机科学的学位是否值得。当时是我在大学里面临是否选择计算机科学专业的时候。我姑姑和一个表哥认为我不该选。他们觉得会编程当然是个既有用又合算的事情，但是他们也坚信，计算机科学更新太快了，当下学到的知识会很快被淘汰掉。所以最好是选一门编程的课程，然后主修经济或者物理这种基本知识一辈子都适用的专业。;我并不相信他们的理论，并且选择了主修计算机专业（抱歉了姑姑和表哥！）其实不难看出，为什么常人会认为计算机科学，或者软件工程这样的专业，每几年就会更新换代。先是诞生了私人计算机，然后是网络，手机，机器学习……科技永远在变化，那么其潜在的技术原理当然也在变化了。当然，最让人惊讶的是，这些基础技术原理，其实基本没变。我相信大部分人要是知道他们计算机中重要软件到底有多老，肯定会震惊。我并不是说软件的表面，毕竟我自己用的最多的火狐浏览器，两周前才更新过。但是如果你打开帮助手册查看 ;之类的工具，你会发现它的上一次更新还是在 2010 年（至少 Mac 系统是这样）。;的初代诞生于 1974 年，那时候的计算机时代好比侏罗纪。现如今，人们（以及程序）在工作中仍然要依赖 grep 做很多事情。;我姑姑和表哥把计算机科技想象成一系列沙滩上的城堡，涨潮时潮水抹去旧的城堡，更加华丽的新城堡又会被建成。其实在现实中的很多领域，我们都是不断地在现有的程序基础上进行迭代。我们也许会时不时的修改这些程序来避免软件崩溃，但是除此之外这些程序不需要额外的维护。;是一个简单的程序，它所解决的问题现在也有意义，所以它至今还存在。很多应用程序的编写都起始于一个很高的角度，就像是在金字塔顶端的基础上构建，而金字塔本身是由曾经解决问题的答案所建成的。现在看来很陈旧的，三四十年前的想法与概念，在很多时候都融入到了你现在计算机上安装了的应用程序里。;我想仔细研究一个这样的老程序，看看它从诞生到现在到底被修改了多少次，这肯定很有趣。我想用 ;这个最简单的 Unix 工具来作为例子。Ken Thompson 在 1969 年开发了初代 ;。如果我跟别人说我计算机里有个 1969 年的程序，这准确吗？;在这几十年里到底经历了几次迭代？我们计算机里的程序到底有多古老？;幸好有;代码仓库，我们可以清晰地了解到，从 1969 年以来，;是如何进化的。我接下来会主要聚焦于我自己 Macbook 上 ;程序的历史实现方式。你会看到，;历史从最初的 Unix 版本，到现在的 Mac 版本，这个程序被重写了比你预想的还要多的次数，但是最终它所实现的功能几乎跟五十年前一模一样。;1969 年，Ken Thompson 和 Dennis Ritchie 开始在 PDP 7 上开发 Unix。这是在 C 语言出现之前，所以早期的 Unix 程序都是用 PDP 7 上用汇编语言开发的。他们使用了专门针对于 Unix 的汇编版本，因为 Ken Thompson 开发了自己的汇编编译器，他在 PDP 7 出厂商DEC 提供的编译器基础上添加了新的功能。Thompson 的改进文档在初始 ;中有收录，在 ;编译器条目下面。;的初代实现使用了 PDP 7 汇编语言。我有添加一些注释来解释每行命令，但是除非你明白 Thompson 编写汇编编译器的一些扩展，不然这个程序还是很难理解。这里有两个重要的点。第一，字符;可以被用于分隔同一行的声明语句。根据 sys 指令的描述，;通常被用于在同一行使用系统调用参数。第二，Thompson 添加了数字 0-9 用于支持“暂存标记”。这些标记可以被整个程序重用，这就像 Unix 编程手册所描述的，“对于程序员思维和汇编语言字符空间的缩减优化”。从手册中，你可以使用 ;来表示下一个标记 ;用 ;来表示上一个标记 ;。举个例子，如果你有个标记为 ;的代码块，你可以从相距很远的下方代码中使用 ;来往上跳回标记代码。(但是你不能往下跳到标记代码，除非你使用;。);关于初代 ;最有意思的是，它包含了两个我们熟知的名字，分别是一个标记为是一个标记为 ;，和一个标记为 ;的代码块，这表示这俩名字要比标准 C 语言库都要历史久远。初代 ;实际上包含了这两个方法的实现。这样的实现方式使得输入字符可以被写入缓冲区，也就是说，读和写不需要以单个字符为单位完成。; 并没有存在很久。Ken Thompson 和 Dennis Ritchie 成功劝说了贝尔实验室帮他们购入了一台 PDP11，以便于他们对 Unix 系统进行扩展与提高。PDP 11 使用的是一种不同的指令集，因此他们不得不重写 ;。对于 ; 代码我也加了注释。第二代使用了针对于新指令集的新版汇编助记符，也利用了 PDP 11中不同的;。（那些源代码中的括号和 ; 符号，是被用来指代不同的地址模式的。）但是 ;第二代中也同样使用了初代中的;和暂存标记，这些功能一定是在 PDP 11 中移植 ;时被保留了下来。;的第二代源代码远比初代要简洁很多。第二代也更加的”Unix-y”，因为它不再需要一串文件名作为命令参数，而是与如今的 ;一样，在没有参数的情况下，从 ;读取输入。对于二代 ;，你也可以使用参数来指定从 ;读取输入数据。;1973 年，为了准备发布第四版 Unix，很大一部分 Unix 系统都用 C 语言重写了一遍。但是 C 语言版本的 ;在 Unix 发布后过了一段时间才出现。;的 ;只出现在第七版 Unix 系统中。这个实现方法非常值得一读，因为它非常简单明了。与其他版本比较，这一版最能作为代表 ;的 K&R C 语言教育演示版本。这段程序的核心就是如下两行：;当然还有更多的代码，但是除了这两行以外，剩下的逻辑更多的是在确保用户不会同时读写同一个文件。另一个有意思的地方是，这个版本的 ;只认得一个标记，;。这个 ;标记可以被用于关闭输入输出缓冲区，不然 ;会默认缓存 512 字节。;在第七版之后，Unix 催生了各种各样的衍生品。MacOS 是基于 Darwin 系统的，而 Darwin 是基于伯克利软件套件（BSD），因此 BSD 是我们最感兴趣的 Unix 分支。BSD 最初是作为Unix附加功能的软件合集，但是它最终成为了一个完整的操作系统。BSD似乎一直在用;的初代版本，一直到第四版 BSD 发布为止。第四版 BSD 也就是 4BSD，它添加了对于新标记的支持。; 能明显的看出是初代的衍生品，不过它添加了一些新的函数用来实现用新标记触发的功能。4BSD 文件系统的命名方法是基于 ;这个变量的，;用于标记指令的输入是从文件，还是 ;读取的。继 ;之后，;和 ;也被用于记录程序中的标记是否被用到。这些命令行标记是 ;添加的最后一批标记；如今至少在 Mac 系统中的 ;命令行手册有列出来这些标记。4BSD 是在 1980 年发布的，所以这一系列的标记有 38 岁了。;最后一次被重写是为了 BSD Net/2，这主要是为了避免软件许可证问题，因此所有 AT&T Unix 衍生代码都被替换为了新代码。BSD Net/2 在 1991 年发布。最后一次重写是由 Kevin Fall 完成的，Kevin Fall 于 1988 年毕业于伯克利，之后他花了一年的时间在计算机系统研究院（CSRG）工作了一年。Fall 告诉我，用 AT&T 代码写的 Unix 工具集列表被挂在了 CSRG 的一面墙上，员工们被告知可以选择感兴趣的工具重写。Fall 选择了 ;和 ;。在如今 Mac 系统的默认 ;版本中，Fall 的名字排在开发者名单前列。他所编写的 ;，虽然是个很简单的程序，但是直到今年还有数百万的用户在使用。;比我们之前看到的版本要长许多。除了支持 ;帮助标记，这一版并没有添加新的功能。理论上来说，这一版代码与 4BSD 版本非常相似。代码之所以长，是因为 Fall 分开了“旧版”和“新版”的逻辑。“旧版”是典型的 ;；它一个字符一个字符的输出。“新版”的 ;包括了 4BSD 命令行选项。这样的分割很有道理，但是使得代码在第一眼看上去比实际复杂很多。代码的最后有个华丽的错误处理方程，这也增加了代码长度。;2001 年，苹果公司发布了 Mac OS X 系统。这次发布对于苹果公司来说非常重要，因为他们花了很多年，走了不少弯路，为了研发能够取代存在了很多年的旧版 Mac OS 系统。苹果公司内部曾经有过两次研发新系统的尝试，但是最终都没能成功；后来，苹果收购了史蒂夫·乔布斯的公司 NeXT，他们公司开发了一款名为 NeXTSTEP 的，基于面向对象编程框架的操作系统。苹果决定使用 NeXTSTEP 作为Mac OS X 的基础。NeXTSTEP 的一部分是基于 BSD 开发的，所以用 NeXTSTEP 作为 Mac OS X 的基础，同时也给苹果系统带来了 BSD 代码风格。;新发布的第一版 Mac OS X中包含了来自 NetBSD 项目的 ;。NetBSD 项目如今仍在不断开发中，它最初是来自 386BSD 的分支。而 386BSD 是直接基于 BSD Net/2 的。所以 Mac OS X 上的 ;就是 Kevin Fall 所写的 ;。唯一变化的是，Kevin Fall 写的错误处理函数 ;被替换成了 ;中的 ;。;是 BSD 基于 C 语言标准库的扩展。;NetBSD 版本的 ;在不久之后被 FreeBSD 版本取代了。根据;，苹果从 Mac OS X 10.3 (Panther)开始，使用 FreeBSD 来取代 NetBSD。但是 Mac OS X 版本的 ;，根据苹果的开软发布记录，一直到 2007 年发布 Mac OS X 10.5 (Leopard) 才被取代。苹果为了发布 Leopard 而引进的 ;一直被沿用到了今天。从 2007 一直到 2018 年，这一版没有做过任何升级或者改变。;所以说 Mac OS 中的 ;是古老的。实际上 ;的出现，比 2007 年的正式发布时间还早两年。;，在 FreeBSD 的Github 镜像中可以看到，是 ;被移植到 Mac OS X 之前 FreeBSD 版的最后一次更新。所以 Mac OS X 中 ;实际上有 13 年的历史了，它并没有与 FreeBSD 的 ;进行同步更新。这里有过一个辩论，软件到底被改动过几次才算是一个新的软件呢；就 ;这个个例来看，它的源代码从 2005 年开始就完全没有改变过了。;如今 Mac OS 系统中的 ;与 Fall 在 1991 年为 BSD Net/2 所写的版本并没有太多不同。最大的不同是添加了一个新的函数用来支持 Unix 上的套接字。一个 FreeBSD 的开发者认为 Fall 所写的 ;函数应该与 ;合并为一个函数 ;。除此之外，最核心的部分还是 Fall 的代码。;我问过 Fall，有几百万苹果用户在使用你所写的 ;，还有很多程序直接或者间接依赖 ;，对此你有什么感想。如今已经是顾问兼最新版 TCP/IP 协议合作者的 Fall 表示，人们对他开发 ;的经历如此的感兴趣，让他觉得非常惊讶。Fall 曾经在计算领域工作过很久，并且有过很多有影响力的项目经历。但是似乎人们对于他在 1989 年开发 ;的那六个月更加感兴趣。;纵观历史上各种伟大的发明，计算机的历史并没有很久。我们仍然在使用有着百年历史的照片和胶卷。但是计算机软件是另外一个类别——目前仍属于高新科技。至少现在的软件是这样。随着计算机产业日渐成熟，我们会不会有一天发现，我们在使用有着百年历史的软件呢？;计算机硬件最终也会更新换代，现在的软件想必是没法跑在一个世纪以后的硬件上。也许高级语言设计的进步，也会导致在将来没有人会使用 C 语言，而 ;也会被其他的语言重写。（不过 C 语言已经存在了五十年了，估计短期内也不会被取代。）不考虑以上这些的话，不如我们就一直用现在这版 ;吧。;我认为，;的历史告诉我们，在计算机科学领域有一些思想是非常耐用的。实际上，对于 ;，它的代码和思想都是很多年前出现的。要说我计算机中的;是1969年的其实并不准确。但如果说我计算机中的 ;是 1989 年 Fall 开发的，就准确多了。很多软件都很古老。也许我们不能单纯的认为计算机科学和软件开发是不断更新换代的领域。我们所开发的系统都是基于历史基础的。在某些时候，我们在开发新代码的同时，也需要去花时间去理解和维护历史代码。"}
{"title": "救命！我的电子邮件发不到 500 英里以外！", "zanNum": "1", "commentNum": "  评论", "markNum": " 1 收藏", "source": "Trey Harris", "coverImage": "http://jbcdn2.b0.upaiyun.com/2018/12/36e31dd89e6544ad8e05bb49bb1da4c7.jpg", "content": "这是一个听起来几乎不可能的事情……我甚至有点后悔将它发到网上，因为它在一个会议上成了一则著名的酒后故事。这个故事略有改动，以保护故事中的人物，以及忽略了一些无关的细节使之更有趣一些。;几年前，当我接到统计系主任的电话时，我正在从事维护校园电子邮件系统的工作。;“我们从部门发送电子邮件时遇到了问题。”;“有什么问题？” 我问。;“我们不能发送超过 500 英里的邮件，”主任解释说。;“咳咳”，我被我喝的拿铁呛了一口，“您再说一遍？”;“我们不能发送距这里超过 500 英里的邮件，”他重复道。 “实际上，更远一点，是 520 英里，但不能更远了。”;“嗯……电子邮件真的不会这样，通常，”我说，试着让我的声音听起来不那么慌乱。我不能和一个系主任说话时显得慌乱，即使是一个像统计系这样的相对没钱的院系。 “是什么让你觉得你不能发送邮件超过 500 英里？”;“这不是我;，”主任有点急躁地回答道。 “我们首先注意到了这种情况是几天前。”;“你等了;？” 我打断他，带点颤音说道。 “这段时间你一直你不能发送电子邮件？”;“我们可以发送电子邮件。只是不超过 ——”;“—— 500 英里，我知道，”我接过他的话，“我知道了。但为什么没有你早点打电话呢？”;“好吧，我们没有收集到足够的数据来确定发生了什么，直到现在。”没错，这是;系的主任。“不管怎么说，我请了一位地理统计学家研究它 ——”;“地理统计学家……”;“—— 是的，她制作了一张地图，显示了我们发送电子邮件能够达到的半径略超过 500 英里。在那个半径范围内有零星的几个无法到达的目的地，但我们永远不能发送比这半径更远的电子邮件。”;“我明白了，”我说，把头埋在我的手中。 “这是什么时候开始的？几天前，你说过，但是那时你的系统做了什么改变？”;“嗯，服务顾问来给我们的服务器打了补丁，并重新启动了它。但我打电话给他，他说他没有碰过邮件系统。”;“好的，让我来看看，我稍后会给你回电话，”我说。我简直觉得我在做梦，这不是愚人节。我试着回想是不是有人恶作剧报复我。;我登录了他们系的服务器，并发送了一些测试邮件。在北卡罗来纳州的三角研究园（ Research Triangle Park），我自己的帐户的测试邮件顺利投递。发往里士满、亚特兰大和华盛顿的也是如此。发往普林斯顿（400 英里）的另一个邮件也正常。;但后来我尝试向孟菲斯（600 英里）发送电子邮件，失败了。波士顿，失败了。底特律，也失败了。我拿出了我的地址簿，开始试图缩小它的范围。纽约（420 英里）工作，但普罗维登斯（580 英里）失败了。;我开始怀疑自己是不是疯了。我试过给住在北卡罗来纳州的朋友发电子邮件，但他的 ISP 在西雅图。谢天谢地，它失败了。如果问题与收件人的地理位置有关，而不是他的邮件服务器，我想我要哭了。;已经确定！虽然令人难以置信，但所报告的问题是真实的、可重复的，我看了一下 ; 文件。它看起来很正常。事实上，它看起来很熟悉。;我把它与我主目录中的 ; 做了个对比。它没有被改过 —— 这是我写的 ;。 而且我相当确定我没有启用某种 “;” 选项。我不知所措，我 telnet 到 SMTP 端口。 服务器愉快地回复了 SunOS sendmail 的横幅消息。;等一下……一个 SunOS sendmail 的横幅消息？当时，即使 Sendmail 8 已经相当成熟，Sun 公司在其操作系统中装的仍然是 Sendmail 5。作为一名优秀的系统管理员，我已经对 Sendmail 8 进行了标准化。并且作为一名优秀的系统管理员，我编写了一个 ;，它使用了 Sendmail 8 中提供的很长的、具有自我描述意义的选项和变量，而不是 Sendmail 5 中使用的那种神秘的标点符号式配置选项。;这个细节一下子又回到了起点，我再次被我现在已经冷掉了的拿铁咖啡渣呛了。 当服务顾问“对服务器打补丁”时，他显然升级了 SunOS 的版本，并且这样做; Sendmail。这次升级会将 sendmail.cf 单独留下，即使它现在是错误的版本。;事实上，Sendmail 5 —— 至少是 Sun 所带的版本，是有一些调整的 —— 它可以处理 Sendmail 8 的 ;，因为大多数规则在那时保持不变。但新的长配置选项 —— 它被视为垃圾，并跳过。 并且 ; 二进制文件编译时没有针对其中大多数设置默认值，因此，在 ; 文件中找不到合适的配置，它们被设置为 0。;被设置为 ; 的配置之一是连接到远程 SMTP 服务器的超时选项。 一些实验证明，在具有典型负载的特定机器上，; 超时将在稍微超过 ;的时间内中止连接调用。;当时我们校园网络的一个奇怪的特点是它是 100％ 交换的。传出的数据包不会出现路由器延迟，直到命中 POP 服务器并到达远端的路由器。因此，连接到附近网络上的轻负载的远程主机的时间实际上主要取决于到目的地的光速的速度，而不是偶然的路由器延迟。;这让我有点晕，我在我的 shell 中输入：;“500 英里，或者稍微多一点点。”"}
{"title": "微软变了！招程序员的流程完全改了", "zanNum": "2", "commentNum": " 1 评论", "markNum": " 5 收藏", "source": "伯乐在线", "coverImage": "http://wx3.sinaimg.cn/mw690/7cc829d3ly1fyvkjyngtoj218g0tmdlf.jpg", "content": "【伯乐在线导读】：在微软新 CEO 萨蒂亚·纳德拉的领导下，微软试图改革公司文化，让整个公司朝着同一个方向发展。为此，微软在 2016 年开始研究「替代面试框架（Alternative Interview Framework）」。这是一种在开发部门进行面试的新方式，目的是减少偏见，更好地测试求职者在工作中实际需要的技能。该团队首先在自己身上测试了面试过程，并在过程中不断改进。;本文作者约翰·蒙哥马利（John Montgomery）是微软项目管理合伙人，他也是新面试流程的负责人。本文写于 2018 年 12 月 15 日，原标题：《Rethinking how we interview in Microsoft’s Developer Division | 对微软开发者部门招聘流程的反思》。以下是伯乐在线的译文：; ;几年前，我有了一系列的顿悟。我刚刚和团队讨论了我们将如何改变项目经理的角色。少关注待办事项，多关注业务；少强调“知道”，多强调“学习和质疑”；更多地关注与客户一对一的接触，而不是聚合数据。我们想把能帮助我们改变这种文化的人带到团队中，但我们仍然在问同样的面试问题，使用同样的面试风格。所以反思了我们是如何面试候选人的，并想出了一些适合我们的方法。;新面试流程我们已经用了一段时间了，我认为有必要分享一下我们所做的，以及学到的东西。;第一个顿悟是我首次从程序员转为项目经理之后，我们注意到，我们仍然在问过去 10 年或更长的时间里一直在问的面试题。如果我们想寻找能够将不同技能和观点的新人带入团队，那些面试题就没有意义了。（补充：我在微软工作时，我们还在问为什么下水道井盖是圆的，一架波音 747 飞机能装满多少个乒乓球，以及如何反转一个链表。在微软工作的 20 年中，我还没有编写代码来反转链表，或用任何类型的球堆满波音 747。）;不仅如此，有时两个面试官会无意中问同样的基本问题。即使在协调面试题的时候，面试官之间也是共享着相同的面试题目录。有些基于行为的面试题并不可怕，但我们并没有特别有效地运用它们。; ;第二次顿悟是在一次会议上。点子冒出来的很快，与会者听着对方的话语，试图把自己的想法融入谈话，我们很快就做出了一些重大决定。至少，我确信这将是一件大事。（我当时被一个客户问题分散了注意力，我正与客户经理和工程团队一起解决客户的问题。这是另一个故事。）不管怎么说，这次会议已经达到了高潮，其中一位与会者，我团队中的一名 PM，他非常聪明，也很安静。他说，“我只是在网上搜索有关我们主题的信息，是的，这个想法行不通。”她的态度比这要好。但让我顿悟的是，并不是所有人都能在那些快节奏的头脑风暴会议中出色表现。很多人（包括我）更喜欢坐着喝杯咖啡，看看数据，试着把事情想清楚。更重要的是，在我的职业生涯中，几乎没有任何一次我们做出重大决定的时候，没有不是离开一段时间，然后用新的眼光、新的数据和新的客户研究来处理点子。;但大多数面试都是快节奏的，那些你从未遇到过的问题，你能有多快地解决？; ;在我和一些工程团队谈论他们是如何将新人带入他们团队的时候，第三个顿悟冒出来了。开发者部门做了很多开源工作（.NET Core、VS Code、TypeScript 等等。作为面试过程的一部分，我们开发团队已经开始与应聘者一起解决某个问题或特性。这就是候选人在和团队一起合作，解决实际问题的过程。;既然“写作就是思考”，我就给自己写了一封电子邮件，讨论我们团队面试流程能有什么样的变化。然后我把自己的想法分享给团队成员，我们开始迭代。 Karen Ng、Amanda Silver、Cindy Alvarez、Nathan Halstead、Anthony Cangialosi、Jeff McAffer、Jessica Rich、Travis Lowdermilk 等成员参与了测试、迭代和测试。;当我们准备推出新面试流程时，我们从很小的地方开始，然后继续学习、迭代，然后扩展。现在，这个新流程（我们称之为“另类面试框架”，因为我们中没有人特别擅长命名事物）是我们的标准实践。我们不断地完善和学习，它对我们非常有效。;下面是我们做的一些不同的事情。;首先，我们要提前几天让候选人知道面试日是什么样的，我们要解决什么样的问题。我们给他们时间去做研究和思考。这并不是说每天上班都是件惊喜的事，那么面试为什么要这样呢?;其次，我们采用了团队正在努力解决的一个实际问题，比如：提高满意度、增加留存率、促进服务或特性的使用。事实上，这是我们正在解决的一个真正的问题，这有助于促进合作对话。;第三，我们让候选人能拿到与正式员工相同的资料。在面试过程中，他们可以自由上网或搜索更多数据。我们经常向候选人提供我们的客户研究、使用数据、设计和模型——几乎我们所有的一切。;我们不是简单地向求职者提问题。面试官和求职者要一起解决问题，所以我们就把求职者当同事看待，一起来解决特定的实际问题。;第五，我们在面试日都遵循一个单一的场景/问题，带领求职者过一遍类似 PM 会经历的过程，从客户或业务问题开始，理解客户待完成的工作要，设计解决方案，将解决方案交到客户手中，最终让客户使用并爱上它。每次面试都侧重于这一流程中的某一不同的阶段。;第六，我们为面试官配对。与一对一的面试不同，我们每次面试都从团队中挑选两个人。我们的最初动机是培养更多的面试官，但有两个面试官在一起还有其他好处。与多个合作者的谈话，不仅更有活力，而且让我们有机会从多个角度观察同一场面试谈话。并不是每个人对同一场面试谈话都有同样的看法，所以，它给了我们一种方法来检查在相同谈话中的无意识偏见。;面试官之间的反馈，我们把保留到面试日结束之时。我们希望每位面试官只根据他们谈话的优点来判断候选人，而不是根据他们之前面试官的意见。我们告诉面试官，不要向别人暗示他们是否倾向于推荐我们雇佣某人。他们把候选人交给下一轮面试官，并总结我们在上一环节中学到的东西。在面试日结束的时候，每个面试官同时提出他们的建议，并解释相应理由。;第八，在每次面试循环的最后，我们不仅要讨论我们在面试中所学到的东西，还要讨论在面试过程中哪些有用，哪些没用。我们再把这些反馈重新应用到面试流程中，流程会变得更好。; ;嗯，我们担心候选人会紧张。面试日有两个面试官和候选人在一起，有真实的问题，还有真实的数据。几乎每个候选人都主动反馈说，新面试流程是独一无二的，真正帮助他们了解我们的业务和团队。即使是那些没有收到录用通知的求职者，也喜欢新的面试流程，明白我们为什么没有录用他们。;我们发现还是有不少要改进的地方。例如，我们 PM 团队是非常有技术性的。许多 PM 将代码 check in 生产产品。这对我们来说是有意义的：我们面试流程的「客户」是开发者，因此拥有来自于创建软件的那种客户理解，是很有帮助的。但在这个过程中，我们并没有很好地深入了解应聘者的技术技能。因此，我们增加了一个面试环节，以进行更技术性的互动。;我们了解到，相对标准面试流程，新流程的一些相应准备工作真心不容易。举个例子，由于求职者正在处理同样的问题，并在白板上写下他们以后需要的东西，我们需要为求职者保留一个专门的空间（会议室或 Focus Room），面试官会去找求职者。;（补注：Focus Room 是一个消除压力的环境，可以帮助你在缓解压力的同时传递信息。）;我们了解到面试是“昂贵的”。“每次两个面试官，我们的时间和人力投入翻了一番，大大增加了日程安排的复杂性。”然而，在最初对费用有些抱怨之后，团队中的每个人都开始看到了好处，就像团队中有更多的人见到了我们潜在的新员工。所以，我们愿意付出这些代价。;最终，招聘流程的目标是把优秀的人员带入团队或公司——确保他们是合适的，会成功，并为他们创造良好的经验，他们才会想要加入。我们和其他几家西雅图的大型科技公司都向一位求职者提供了竞争性的工作机会，她特别选择了我们的团队，因为她非常喜欢这个过程。她碰巧成为了我们在早期实验阶段的候选人之一，她还在这里上班，做的很好。其他很多候选人也类似。所以我说，我们的新面试流程表现的很好。我们仍在学习，但到目前为止，新面试流程的成果已超过我们的预期。"}
